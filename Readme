# JSON → CSV Converter

**Repositorio / Proyecto:** `org.edu.university.converter`

**Descripción breve**

Proyecto Java que convierte archivos JSON (objetos o arreglos) a CSV. Está pensado para manejar estructuras JSON anidadas mediante *flattening* (notación de puntos para claves anidadas) y exportar datos usando OpenCSV.

---

## Contenido del repositorio (archivos clave)

* `MainApp` — Punto de entrada, parseo de argumentos de línea de comandos, prompts interactivos opcionales y ejecución del flujo de validación + conversión.
* `FileValidator` — Validaciones centralizadas del archivo JSON (existencia, extensión `.json`, accesibilidad, tamaño, sintaxis JSON). Incluye la excepción interna `ValidationException`.
* `JsonReader` — Lee el JSON y realiza el *flattening* recursivo. Arrays se serializan como JSON en una sola columna; valores nulos se convierten en cadena vacía.
* `CsvWriter2` — Escribe datos a CSV usando OpenCSV; recopila cabeceras (union de todas las claves) preservando el orden de inserción y crea el archivo de manera segura (`CREATE_NEW` para evitar sobrescrituras accidental).
* `JsonToCsvConverter` — Orquestador: conecta `JsonReader` y `CsvWriter2` para realizar la conversión.
* Tests:

  * `CsvWriterTest` — Genera múltiples archivos CSV de prueba y valida su creación.
  * `JsonReaderTest` — Valida el *flattening* y lectura de JSON de ejemplo.
  * `JsonToCsvConverterTest` — Prueba la conversión de JSON a CSV, valida filas y salida de archivo.

---

## Requisitos / Dependencias (Maven)

Añade estas dependencias en tu `pom.xml` (ejemplo):

```xml
<dependencies>
  <!-- Jackson para parseo JSON -->
  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.15.2</version>
  </dependency>

  <!-- OpenCSV para escritura segura de CSV -->
  <dependency>
    <groupId>com.opencsv</groupId>
    <artifactId>opencsv</artifactId>
    <version>5.7.1</version>
  </dependency>

  <!-- JUnit 5 para pruebas -->
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.0</version>
    <scope>test</scope>
  </dependency>
</dependencies>
```

> Nota: ajusta versiones según el ecosistema de tu proyecto.

---

## Uso (línea de comandos)

Compilar y ejecutar (Maven):

```bash
mvn clean package
java -jar target/your-artifact.jar --input=datos/sample.json --output=exports/result.csv --delimiter=,
```

Opciones y comportamiento:

* `--input=<path>`: ruta al archivo JSON de entrada. Si no se especifica, se puede usar el primer argumento posicional.
* `--output=<path>`: ruta al CSV de salida (por defecto `exports/output.csv`).
* `--delimiter=<char>`: delimitador CSV (ej: `,` `;` `\t`).
* `--no-prompt`: si se pasa, deshabilita la interacción por consola.

Si no se pasan argumentos y no se usa `--no-prompt`, la aplicación pregunta interactivamente por rutas alternativas.

---

## Formato de entrada y reglas de *flattening*

**Entrada válida:** archivo `.json` cuyo root sea un objeto (object) o un arreglo (array) de objetos.

**Reglas de aplanado (flattening):**

* Objetos anidados → claves en notación de puntos. Ejemplo:

```json
{ "user": { "name": "Alice" } }
```

→ `user.name, Alice`

* Arrays → se serializa el array completo en la columna correspondiente como texto JSON (ej: `["a","b"]`).
* Valores nulos → se transforman a cadena vacía `""`.
* Cabeceras del CSV → unión de todas las claves encontradas en los registros, respetando orden de descubrimiento (LinkedHashSet).

---

## Comportamiento del escritor CSV (`CsvWriter2`)

* Escribe headers primero.
* Crea el directorio padre si es necesario.
* Utiliza `StandardOpenOption.CREATE_NEW` para evitar sobrescribir archivos existentes. Si el archivo ya existe, lanza `IOException` con mensaje claro.
* Codificación UTF-8.
* Permite elegir delimitador.

---

## Validación de archivo (`FileValidator`)

Validaciones principales:

1. Ruta no nula ni vacía.
2. Archivo existe y es regular (no directorio).
3. Extensión `.json` (insensible a mayúsculas).
4. Archivo legible y no vacío.
5. Sintaxis JSON válida y root `object` o `array`.

Métodos importantes:

* `isValidJsonFile(String path)` → comprobación rápida (existencia + extensión).
* `validateJsonFile(String path)` → validación completa con mensajes en `System.err`.
* `validateOrThrow(String path)` → lanza `ValidationException` si no pasa validación.

---

## Tests (cómo ejecutarlos y qué verifican)

Ejecutar tests con Maven:

```bash
mvn test
```

### Descripción de tests incluidos

* `CsvWriterTest`

  * Crea 10 archivos CSV de prueba (`target/test-csv-writer-1.csv` ... `-10.csv`).
  * Verifica existencia y tamaño > 0.
  * Útil para comprobar que OpenCSV y la escritura en disco funcionan correctamente.

* `JsonReaderTest`

  * Crea un JSON de ejemplo en `target/test-sample.json`.
  * Llama a `JsonReader.readAndFlatten(...)`.
  * Verifica que se obtienen 2 registros y que campos aplanados (ej. `publication.title`) contienen los valores esperados.

* `JsonToCsvConverterTest`

  * Crea un JSON temporal y ejecuta `JsonToCsvConverter.convert(...)`.
  * Valida que el CSV de salida existe, no está vacío y que el número de filas procesadas coincide con el esperado.

> Recomendación: Ejecuta la suite de tests en un entorno CI (GitHub Actions, GitLab CI, Jenkins) para asegurar integridad en cada push.

---

## Ejemplos

### JSON de ejemplo

```json
[
  {
    "id": 1,
    "author": "Beatriz Solórzano",
    "publication": { "title": "Data Integration", "year": 2023 }
  },
  {
    "id": 2,
    "author": "Juan Pérez",
    "publication": { "title": "Automation Reports", "year": 2024 }
  }
]
```

### CSV esperado (simplificado)

```
id,author,publication.title,publication.year
1,Beatriz Solórzano,Data Integration,2023
2,Juan Pérez,Automation Reports,2024
```

---

## Manejo de errores y mensajes

* Mensajes amigables en consola para condiciones comunes (archivo no encontrado, sintaxis inválida, archivo ya existe, etc.).
* En `MainApp`, la excepción se captura y se imprime `e.getMessage()` + stacktrace para depuración.
* `CsvWriter2` lanza `IOException` con mensaje claro cuando el archivo ya existe.

---

## Buenas prácticas y puntos clave (resumen rápido)

* Asegúrate de que el JSON tenga root `object` o `array`.
* Revisar encoding: UTF-8 por defecto; evita archivos con codificación distinta.
* Si trabajas con arrays dentro del JSON y los quieres separar en columnas individuales, extiende `JsonReader` para expandir arrays en múltiples columnas (actualmente se serializan como JSON en una sola celda).
* Mantén el orden de cabeceras consistente: `CsvWriter2` usa `LinkedHashSet` para preservar orden de aparición.
* `CREATE_NEW` protege contra sobrescritura accidental; si quieres sobrescribir, cambia la opción de apertura de archivo.

---

Interfaz gráfica — JsonToCsvGui (Java Swing)

Se ha añadido una interfaz gráfica de usuario (GUI) basada en Java Swing que integra y adapta el flujo de trabajo ya descrito (FileValidator, JsonReader, CsvWriter2, JsonToCsvConverter). Esta sección documenta el uso, la integración y consideraciones específicas.
Ubicación recomendada

Coloca la clase en tu proyecto con la siguiente ruta de paquete y archivo:

src/main/java/org/edu/university/converter/ui/JsonToCsvGui.java
Objetivo

Proveer una UI sencilla e interactiva para:

Seleccionar el archivo JSON de entrada.

Definir o seleccionar el archivo CSV de salida.

Elegir el delimitador (, ; o ).

Habilitar sobrescritura del archivo de salida de forma segura.

Visualizar logs en tiempo de ejecución y progreso de la conversión.

Características clave

Integración directa: llama a FileValidator para validación rápida/completa y a JsonToCsvConverter para ejecutar la conversión.

Protección contra sobrescritura: CsvWriter2 usa CREATE_NEW, por lo que la GUI ofrece una opción Overwrite if exists que, si está marcada, elimina el archivo existente antes de convertir (permitiendo así que CsvWriter2 cree el archivo limpio). 
Si no está marcada, pregunta al usuario antes de sobrescribir.

Ejecución no bloqueante: la conversión se ejecuta en un SwingWorker para mantener la interfaz responsiva; la barra de progreso es indicadora indeterminate mientras se procesa.

Sugerencia automática de salida: al seleccionar un archivo JSON, la GUI sugiere automáticamente una ruta de salida en exports/<nombre>.csv si no se ha especificado una ruta previa.

Campo de delimitador: acepta la primera tecla como delimitador. Si el usuario escribe la GUI lo interpreta como tabulación.

Área de logs: muestra mensajes de progreso, errores y confirmaciones en tiempo real.

Uso (ejecutar la GUI)

Compila el proyecto y ejecuta la clase JsonToCsvGui. Ejemplo con Maven:

mvn clean package
mvn -Dexec.mainClass="org.edu.university.converter.ui.JsonToCsvGui" exec:java

O si usas un JAR ejecutable (incluyendo dependencias):

java -cp target/your-fat-jar.jar org.edu.university.converter.ui.JsonToCsvGui

También la clase main acepta argumentos opcionales: java ... JsonToCsvGui <input.json> <output.csv> para prellenar los campos.
                                                                                             

Conclusión
Este proyecto provee una solución simple y robusta para transformar archivos JSON a CSV manteniendo integridad en codificación y estructura. 
Está pensado como una utilidad reutilizable, con validación previa para evitar errores comunes y tests automatizados que verifican los componentes principales
(JsonReader, CsvWriter2 y el orquestador JsonToCsvConverter). Es una buena base para ampliar transformaciones más avanzadas de datos (normalización de arrays, mapeos personalizados, perfiles de columna, etc.).
                                                                                             

                                                                                             
                                                                                             
                                                                                             
